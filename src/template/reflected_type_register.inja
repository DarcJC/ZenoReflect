R"INJA(
#include "reflect/type"
#include "reflect/traits/type_traits"
#include "reflect/container/any"
#include "reflect/reflection.generated.hpp"
## for header_path in headers
#include "{{ header_path }}"
## endfor

using namespace zeno::reflect;

## for type_info in types
/// ==== Begin {{ type_info.qualified_name }} Register ====
namespace {
    class Type{{- type_info.normal_name -}}_Instance : public TypeBase {
    public:
        using Super = TypeBase;

        Type{{- type_info.normal_name -}}_Instance(const ReflectedTypeInfo& type_info) : Super(type_info) {
        }

        virtual std::size_t type_hash() const override {
            return get_rtti_info().hash_code();
        }

        virtual const ArrayList<ITypeConstructor*>& get_constructors() const override {
            return get_internal_constructors();
        }

        virtual const ArrayList<IMemberFunction*>& get_member_functions() const override {
            return get_internal_member_functions();
        }

        static const RTTITypeInfo& get_rtti_info() {
            // Note: namespace required here because MSVC has a pre-defined type named type_info
            return zeno::reflect::type_info<{{ type_info.canonical_typename }}>();
        }

        inline static ArrayList<ITypeConstructor*>& get_internal_constructors() {
            static ArrayList<ITypeConstructor*> internal_constructors { {{ type_info.num_ctor }} };
            return internal_constructors;
        }

        inline static ArrayList<IMemberFunction*>& get_internal_member_functions() {
            static ArrayList<IMemberFunction*> internal_funcs { {{ default(type_info.num_func, 0) }} };
            return internal_funcs;
        }

    };

## for params in type_info.ctors
    class ConstructorWrapperFor{{- type_info.normal_name -}}_{{- loop.index -}} : public ITypeConstructor {
    public:
        ConstructorWrapperFor{{- type_info.normal_name -}}_{{- loop.index -}}() : ITypeConstructor(get_type<{{ type_info.canonical_typename }}>()) {}

        virtual const ArrayList<RTTITypeInfo>& get_params() const override {
            static ArrayList<RTTITypeInfo> STATIC_LIST {
## for param in params
                    type_info<{{ param }}>(),
## endfor
            };
            return STATIC_LIST;
        }

        virtual const ArrayList<RTTITypeInfo>& get_params_dacayed() const override {
            static ArrayList<RTTITypeInfo> STATIC_LIST {
## for param in params
                    type_info<TTDecay<{{ param }}>>(),
## endfor
            };
            return STATIC_LIST;
        }

        virtual void* new_instance(const ArrayList<Any>& params = {}) const override {
            if (is_suitable_to_invoke(params)) {
## for param in params
                Any& any{{- loop.index }} = const_cast<Any&>(params[{{ loop.index }}]);
                {{ param }} p{{- loop.index }} = any_cast<{{ param }}>(any{{- loop.index -}});
## endfor
                return new {{ type_info.canonical_typename }}
                (
## for param in params
                    p{{- loop.index -}} {% if loop.index1 != length(params) %},{% endif %}
## endfor
                );
            }
            return nullptr;
        }

        virtual Any create_instance(const ArrayList<Any>& params = {}) const override {
            Any val{};
            if (is_suitable_to_invoke(params)) {
                // Just praying for NRVO is working
## for param in params
                Any& any{{- loop.index }} = const_cast<Any&>(params[{{ loop.index }}]);
                {{ param }} p{{- loop.index }} = any_cast<{{ param }}>(any{{- loop.index -}});
## endfor
                val.emplace<{{ type_info.canonical_typename }}>
                (
## for param in params
                    p{{- loop.index -}} {% if loop.index1 != length(params) %},{% endif %}
## endfor
                );
            }
            return val;
        }
    };
## endfor

    struct S{{- type_info.normal_name -}}Registrator {
        S{{- type_info.normal_name -}}Registrator() {
            ReflectedTypeInfo info {};
            info.prefix = "{{ prefix }}";
            info.qualified_name = "{{ type_info.qualified_name }}";
            info.canonical_typename = "{{ type_info.canonical_typename }}";
            Type{{- type_info.normal_name -}}_Instance* type_impl = new Type{{- type_info.normal_name -}}_Instance(info);

            {
                ArrayList<ITypeConstructor*>& constructors = type_impl->get_internal_constructors();
                {
## for params in type_info.ctors
                    constructors.add_item(new ConstructorWrapperFor{{- type_info.normal_name -}}_{{- loop.index -}}());
## endfor
                }
            }

            (ReflectionRegistry::get())->add(type_impl);
        }
    };
    static S{{- type_info.normal_name -}}Registrator global_S{{- type_info.normal_name -}}Registrator{};
}
/// ==== End {{ type_info.qualified_name }} Register ====
## endfor
)INJA";
