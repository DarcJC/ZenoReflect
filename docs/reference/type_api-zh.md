# 反射接口

总的来说，提供了两个可以直接通过`typename`表达式获取类型信息的接口：

```cpp
// 获取生成的RTTI信息
zeno::reflect::type_info<T>()

// 获取反射类型信息
zeno::reflect::get_type<T>()
```

## RTTI信息

众所周知，C++的运行时类型信息（RTTI）并不保证二进制之间的ABI兼容，不过这倒也好理解，因为这是正常来说是编译期就生成在只读数据段上的东西（当然也不一定就要存在段上）。
不过这也是因为C++肯定不会要求全局唯一的类型名称，编译器只好自己生成一个在翻译单元内唯一的名称和哈希值。

因此我们为反射类型及*被反射类型中所使用用到的类型*生成了一个编译期可访问的RTTI信息，这个信息保证在不违反本项目限制的情况下，在任何平台唯一。

这个信息可以通过下面这个模板函数访问。你在使用这个函数前，还需要引入生成的头文件`#include "reflect/reflection.generated.hpp"`，以便编译器正确获取类型模板特化。

```cpp
zeno::reflect::type_info<T>()
```

## 反射信息

至于`get_type<T>()`接口，它会返回一个`TypeHandle`对象，这是一个类型信息句柄，复制开销较低。

在**确保**这是一个拥有反射标记的类型的前提下，可以直接使用`->`操作符访问`TypeBase`接口。
当然即使它并不是一个反射类型，也可以进行类型对比。

## 更直接的反射信息

既然是运行时反射，当然也支持从类型名称来获取反射信息。不过这些与类型注册表相关的接口目前没有稳定，随时可能进行修改。

可以看`crates/libreflect/include/reflect/registry.hpp`文件。

