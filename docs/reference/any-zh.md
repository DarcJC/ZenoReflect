# Any

`Any`类型用于提供类型擦除后的通用对象操作。它代表的是一个任意类型的对象，**不能**代表引用和指针。

换句话说，`Any`保存着一个对象的值，而非指向它的内存地址。所以请注意下列写法：

```cpp
Foo foo;

// 如果可以移动，那么移动构造函数会被调用。否则调用拷贝构造函数。
Any any(zeno::reflect::move(foo));

// 必然会调用拷贝构造函数
Any any(foo);

```

注意上面的例子，如果类型不能拷贝构造且不能移动构造，或者有什么兼容的隐式转换类型的构造函数，那么将会导致编译错误。

所以，我们提供了一个`make_any`方法以便**in-place**构造一个Any对象。

```cpp
// 假设Foo有个有着三个int类型参数的构造函数
Any any = zeno::reflect::make_any<Foo>(123, 456, 789);
```

## 移动和复制

正如上文所述，如果通过值来传递`Any`：

```cpp
Any origin_any = make_any<Foo>();

// 会触发拷贝构造对内部保存的值进行克隆
// 如果无法拷贝构造，则会抛出异常
Any duplicated_any = origin_any;
```

如果不想触发克隆操作，则需要通过 指针、引用或是移动语义 进行传递。
