#pragma once

#include <cstdint>
#include "reflect/polyfill.hpp"
#include "reflect/container/string"
#include "reflect/container/arraylist"
#include "reflect/container/any"
#include "reflect/traits/type_traits"

namespace zeno
{
namespace reflect 
{
    enum class TypeFlags : uint8_t {
        IsClass = 0,
        IsTemplateInstance,
        IsEnumeration,
        IsArray,
        IsPointer,
        IsArithmetic,
        IsFunctionPointer,
        IsMemberFieldPointer,
        IsMemberFunctionPointer,
        Max,
    };

    class ITypeConstructor {
    public:
        virtual void* new_instance(const ArrayList<Any>& params = {}) = 0;

        template <typename T>
        T* new_instance_typed(const ArrayList<Any>& params = {}) {
            return reinterpret_cast<T*>(new_instance(params));
        }

        // template <typename T>
        // TypeInstance<T> new_instance_proxied(const std::vector<std::any>& params = {}) {
        //     return TypeInstance<T>(new_instance_typed<T>(params));
        // }

    protected:
        class TypeBase* m_type = nullptr;
    };

    struct ReflectedTypeInfo {
        // A prefix name. Used to avoid name conflicts between difference modules
        StringView prefix;
        StringView qualified_name;
        StringView canonical_typename;
        bool internal_flags[static_cast<size_t>(TypeFlags::Max)] = { false };
    };

    class TypeBase {
    public:
        TypeBase() = delete;
        virtual ~TypeBase() = default;

        virtual std::size_t type_hash() const = 0;

        virtual bool operator==(const TypeBase& other) const;
        virtual bool operator!=(const TypeBase& other) const;
    protected:
        TypeBase(const ReflectedTypeInfo& type_info);

        ReflectedTypeInfo m_type_info;
    };

    class TypeHandle {
        mutable union {
            TypeBase* type_info = nullptr;
            size_t rtti_hash;
        } m_handle;
        mutable bool is_reflected_type;

    public:
        TypeHandle(TypeBase* type_info);

        template <typename T>
        REFLECT_CONSTEXPR_OR_INLINE TypeHandle(TTDecay<T>* = nullptr) {
            m_handle.rtti_hash = type_info<TTDecay<T>>.hash_code();
            is_reflected_type = false;
        }

        bool operator==(const TypeHandle& other) const;
        bool operator!=(const TypeHandle& other) const;

        TypeBase* get_reflected_type_or_null() const;
        TypeBase* operator->() const;
    };

    /// Utilities for type reflection

    /**
     * Returns the type info of a given type name.
     * 
     * The real implementation is generated by the reflection generation tool and included in target's pch.
    */
    template <typename T>
    LIBREFLECT_INLINE TypeHandle* get_type() {
        return nullptr;
    }
}
}
