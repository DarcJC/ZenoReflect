#pragma once

#include <vector>
#include <any>
#include <optional>
#include <string_view>

namespace zeno
{
namespace reflect 
{
    enum class TypeFlags : uint8_t {
        IsClass = 0,
        IsTemplateInstance,
        IsEnumeration,
        IsArray,
        IsPointer,
        IsArithmetic,
        IsFunctionPointer,
        IsMemberFieldPointer,
        IsMemberFunctionPointer,
        Max,
    };

    template <typename T>
    class TypeInstance {
        T* internal_ptr;

    public:
        using Type = T;

        TypeInstance(T* inst): internal_ptr(inst) { REFLECT_CHECK(internal_ptr != nullptr, "Type instance can't be null"); }

        TypeInstance(const TypeInstance&) = delete;
        TypeInstance& operator=(const TypeInstance&) = delete;

        TypeInstance(TypeInstance&& inst_to_move) noexcept : internal_ptr(inst_to_move.internal_ptr) {
            inst_to_move.internal_ptr = nullptr;
        }
        TypeInstance& operator=(TypeInstance&& inst_to_move) noexcept {
            if (this != &other) {
                delete internal_ptr;
                internal_ptr = inst_to_move.internal_ptr;
                inst_to_move.internal_ptr = nullptr;
            }
            return *this;
        }

        ~TypeInstance() {
            delete internal_ptr;
        }

        bool is_valid() const {
            return internal_ptr != nullptr;
        }

        T* operator->() const {
            return ptr;
        }

        T& operator*() const {
            return *ptr;
        }
    };

    class ITypeConstructor {
    public:
        virtual void* new_instance(const std::vector<std::any>& params = {}) = 0;

        template <typename T>
        T* new_instance_typed(const std::vector<std::any>& params = {}) {
            return reinterpret_cast<T*>(new_instance(params));
        }

        template <typename T>
        TypeInstance<T> new_instance_proxied(const std::vector<std::any>& params = {}) {
            return TypeInstance<T>(new_instance_typed<T>(params));
        }

    protected:
        class TypeBase* m_type = nullptr;
    };

    struct TypeInfo {
        // A prefix name. Used to avoid name conflicts between difference modules
        std::string prefix;
        std::string qualified_name;
        std::string canonical_typename;
        bool internal_flags[static_cast<size_t>(TypeFlags::Max)] = { false };
    };

    class TypeBase {
        virtual std::size_t type_hash() const = 0;
    protected:
        std::optional<TypeInfo> m_type_info;
    };

    class TypeHandle {
        union {
            TypeBase* type_info = nullptr;
            size_t rtti_hash = 0;
        } m_handle;
    };

    /// Utilities for type reflection

    /**
     * Returns the type info of a given type name.
     * 
     * The real implementation is generated by the reflection generation tool and included in target's pch.
    */
    template <typename T>
    LIBREFLECT_INLINE TypeHandle* get_type() {
        return nullptr;
    }
}
}
